{"version":3,"sources":["webpack://smartcharts/./app/connection/StreamManager.ts"],"names":["StreamManager","connection","MAX_CACHE_TICKS","last_tick_timestamp","Date","getTime","_connection","_streams","_streamIds","_tickHistoryCache","_tickHistoryPromises","_beingForgotten","msgType","on","_onTick","bind","onClosed","_onConnectionClosed","data","console","log","warn","key","_getKey","echo_req","current_tick_timestamp","error","msg_type","id","_cacheTick","emitTick","undefined","_forgetStream","Object","keys","subscriberCount","cache","cloneTickHistoryResponse","response","ohlc","candles","close","epoch","open_time","high","low","open","candle","lastCandle","length","push","shift","tick","history","prices","times","price","quote","time","stream","destroy","send","forget","then","request","Stream","subscribePromise","_onReceiveTickHistory","onNoSubscriber","req","callback","_createNewStream","tickHistoryResponse","responseStart","start","patchRequest","subscribe","end","String","patch","mergeTickHistory","onStream","offStream","symbol","ticks_history","granularity","others","clone","slice"],"mappings":"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","file":"main.953f92.hot-update.js","sourcesContent":["import {\n    Candles,\n    History,\n    TicksHistoryRequest,\n    TicksHistoryResponse,\n    TickSpotData,\n    TicksStreamResponse,\n} from '@deriv/api-types';\nimport { ArrayElement, OHLCStreamResponse, TBinaryAPIRequest } from 'src/types';\nimport ConnectionManager from './ConnectionManager';\nimport Stream from './Stream';\nimport { mergeTickHistory } from './tickUtils';\n\nclass StreamManager {\n    MAX_CACHE_TICKS = 5000;\n    last_tick_timestamp = new Date().getTime();\n    _connection: ConnectionManager;\n    _streams: Record<string, Stream> = {};\n    _streamIds: Record<string, string | undefined> = {};\n    _tickHistoryCache: Record<string, Required<TicksHistoryResponse>> = {};\n    _tickHistoryPromises: Record<string, Promise<Required<TicksHistoryResponse>>> = {};\n    _beingForgotten: Record<string, boolean> = {};\n\n    constructor(connection: ConnectionManager) {\n        this._connection = connection;\n\n        for (const msgType of ['tick', 'ohlc']) {\n            this._connection.on(msgType, this._onTick.bind(this));\n        }\n        this._connection.onClosed(this._onConnectionClosed.bind(this));\n    }\n\n    _onTick(data: TicksStreamResponse) {\n        console.log('');\n        console.warn('ON TICK: ');\n        console.log(this.last_tick_timestamp);\n        const key = this._getKey((data.echo_req as unknown) as TicksHistoryRequest);\n        const current_tick_timestamp = new Date().getTime();\n\n        if (this._streams[key] && this._tickHistoryCache[key]) {\n            console.error(current_tick_timestamp - this.last_tick_timestamp);\n\n            this._streamIds[key] = data[data.msg_type]?.id;\n            this._cacheTick(key, data);\n            this._streams[key].emitTick(data);\n\n            // if (current_tick_timestamp - this.last_tick_timestamp < 2 * 1000) {\n            //     this._streamIds[key] = data[data.msg_type]?.id;\n            //     this._cacheTick(key, data);\n            //     this._streams[key].emitTick(data);\n            // }\n            // else {\n            //     console.error('BWOKEN');\n            //     // this._mainStore.chart.refreshChart();\n            // }\n            this.last_tick_timestamp = current_tick_timestamp;\n        } else if (this._beingForgotten[key] === undefined) {\n            // There could be the possibility a stream could still enter even though\n            // it is no longer in used. This is because we can't know the stream ID\n            // from the initial response; we have to wait for the next tick to retrieve it.\n            // In such scenario we need to forget these \"orphaned\" streams:\n            this._streamIds[key] = data[data.msg_type]?.id;\n            this._forgetStream(key);\n        }\n    }\n\n    _onConnectionClosed() {\n        // StreamManager simply discards all streams upon disconnection;\n        // It is not its responsibility to reestablish the streams upon reconnection.\n        this._streamIds = {}; // set it to blank so that forget requests do not get called\n        for (const key of Object.keys(this._streams)) {\n            if (this._streams[key].subscriberCount !== 0) {\n                this._forgetStream(key);\n            }\n        }\n    }\n\n    _onReceiveTickHistory(data: Required<TicksHistoryResponse>) {\n        const key = this._getKey((data.echo_req as unknown) as TicksHistoryRequest);\n        const cache = StreamManager.cloneTickHistoryResponse(data);\n        if (cache) {\n            this._tickHistoryCache[key] = cache;\n        }\n        delete this._tickHistoryPromises[key];\n    }\n\n    _cacheTick(key: string, response: TicksStreamResponse | OHLCStreamResponse) {\n        if ('ohlc' in response) {\n            const { ohlc } = response as OHLCStreamResponse;\n            const candles = this._tickHistoryCache[key].candles as Candles;\n            const { close, open_time: epoch, high, low, open } = ohlc;\n            const candle: ArrayElement<Candles> = {\n                close: (close as unknown) as number,\n                high: (high as unknown) as number,\n                low: (low as unknown) as number,\n                open: (open as unknown) as number,\n                epoch,\n            };\n            const lastCandle = candles[candles.length - 1] as Required<Candles[0]>;\n            if (lastCandle && candle.epoch && +lastCandle.epoch === +candle.epoch) {\n                candles[candles.length - 1] = candle;\n            } else {\n                candles.push(candle);\n\n                if (candles.length > this.MAX_CACHE_TICKS) {\n                    candles.shift();\n                }\n            }\n        } else if ('tick' in response) {\n            const { tick } = response;\n            const history = this._tickHistoryCache[key].history;\n\n            const { prices, times } = history as Required<History>;\n            const { quote: price, epoch: time } = tick as Required<TickSpotData>;\n\n            prices.push(price);\n            times.push(time);\n\n            if (prices.length > this.MAX_CACHE_TICKS) {\n                prices.shift();\n                times.shift();\n            }\n        }\n    }\n\n    _forgetStream(key: string) {\n        const stream = this._streams[key];\n        if (stream) {\n            // Note that destroying a stream also removes all subscribed events\n            stream.destroy();\n            delete this._streams[key];\n        }\n\n        if (this._streamIds[key]) {\n            const id = this._streamIds[key];\n            this._beingForgotten[key] = true;\n            this._connection.send({ forget: id }).then(() => {\n                delete this._beingForgotten[key];\n                delete this._streamIds[key];\n            });\n        }\n\n        if (this._tickHistoryCache[key]) {\n            delete this._tickHistoryCache[key];\n        }\n    }\n\n    _createNewStream(request: TicksHistoryRequest) {\n        const key = this._getKey(request);\n        const stream = new Stream();\n        this._streams[key] = stream;\n        const subscribePromise = this._connection.send((request as unknown) as TBinaryAPIRequest);\n        this._tickHistoryPromises[key] = subscribePromise as Promise<Required<TicksHistoryResponse>>;\n\n        subscribePromise\n            .then(response => {\n                this._onReceiveTickHistory(response as Required<TicksHistoryResponse>);\n                if (response.error) {\n                    this._forgetStream(key);\n                }\n            })\n            .catch(() => {\n                this._forgetStream(key);\n            });\n\n        stream.onNoSubscriber(() => this._forgetStream(key));\n\n        return stream;\n    }\n\n    async subscribe(req: TBinaryAPIRequest, callback: (response: TicksHistoryResponse) => void) {\n        const request = (req as unknown) as TicksHistoryRequest;\n        const key = this._getKey(request);\n        let stream = this._streams[key];\n        if (!stream) {\n            stream = this._createNewStream(request);\n        }\n\n        let tickHistoryResponse = this._tickHistoryCache[key];\n        if (!tickHistoryResponse) {\n            tickHistoryResponse = await this._tickHistoryPromises[key];\n        }\n\n        const responseStart = ((tickHistoryResponse.echo_req as unknown) as TicksHistoryRequest).start;\n        if (responseStart && request.start && responseStart > request.start) {\n            // request needs more data\n            const patchRequest = { ...request };\n            delete patchRequest.subscribe;\n            const { history, candles } = tickHistoryResponse as Required<TicksHistoryResponse>;\n            patchRequest.end = String(history && history.times?.[0] ? +history.times[0] : candles[0].epoch || '');\n            const patch = (await this._connection.send(patchRequest)) as Required<TicksHistoryResponse>;\n            tickHistoryResponse = mergeTickHistory(tickHistoryResponse, patch);\n        }\n\n        if (tickHistoryResponse.error) {\n            callback(tickHistoryResponse);\n        } else {\n            // If cache data is available, send a copy otherwise we risk\n            // mutating the cache outside of StreamManager\n            callback(StreamManager.cloneTickHistoryResponse(tickHistoryResponse));\n        }\n\n        stream.onStream(callback);\n    }\n\n    forget(request: TBinaryAPIRequest, callback: (response: TicksHistoryResponse) => void) {\n        const key = this._getKey((request as unknown) as TicksHistoryRequest);\n        const stream = this._streams[key];\n        if (stream) {\n            stream.offStream(callback);\n        }\n    }\n\n    _getKey({ ticks_history: symbol, granularity }: TicksHistoryRequest) {\n        return `${symbol}-${granularity || 0}`;\n    }\n\n    static cloneTickHistoryResponse({ history, candles, ...others }: Required<TicksHistoryResponse>) {\n        let clone: TicksHistoryResponse | null = null;\n\n        if (history) {\n            const { prices, times } = history as Required<History>;\n            clone = {\n                ...others,\n                history: {\n                    prices: prices.slice(0),\n                    times: times.slice(0),\n                },\n            };\n        } else if (candles) {\n            clone = { ...others, candles: candles.slice(0) };\n        }\n\n        return clone as Required<TicksHistoryResponse>;\n    }\n}\n\nexport default StreamManager;\n"],"sourceRoot":""}