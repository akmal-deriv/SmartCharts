{"version":3,"sources":["webpack://smartcharts/./app/connection/StreamManager.ts"],"names":["StreamManager","connection","MAX_CACHE_TICKS","_connection","_streams","_streamIds","_tickHistoryCache","_tickHistoryPromises","_beingForgotten","msgType","on","_onTick","bind","onClosed","_onConnectionClosed","data","key","_getKey","echo_req","msg_type","id","_cacheTick","emitTick","undefined","_forgetStream","Object","keys","subscriberCount","cache","cloneTickHistoryResponse","response","ohlc","candles","close","epoch","open_time","high","low","open","candle","lastCandle","length","push","shift","tick","history","prices","times","price","quote","time","stream","destroy","send","forget","then","request","Stream","subscribePromise","_onReceiveTickHistory","error","onNoSubscriber","req","callback","_createNewStream","tickHistoryResponse","responseStart","start","patchRequest","subscribe","end","String","patch","mergeTickHistory","onStream","offStream","symbol","ticks_history","granularity","others","clone","slice"],"mappings":"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","file":"main.640294.hot-update.js","sourcesContent":["import {\n    Candles,\n    History,\n    TicksHistoryRequest,\n    TicksHistoryResponse,\n    TickSpotData,\n    TicksStreamResponse,\n} from '@deriv/api-types';\nimport { ArrayElement, OHLCStreamResponse, TBinaryAPIRequest } from 'src/types';\nimport ConnectionManager from './ConnectionManager';\nimport Stream from './Stream';\nimport { mergeTickHistory } from './tickUtils';\n\nclass StreamManager {\n    MAX_CACHE_TICKS = 5000;\n    _connection: ConnectionManager;\n    _streams: Record<string, Stream> = {};\n    _streamIds: Record<string, string | undefined> = {};\n    _tickHistoryCache: Record<string, Required<TicksHistoryResponse>> = {};\n    _tickHistoryPromises: Record<string, Promise<Required<TicksHistoryResponse>>> = {};\n    _beingForgotten: Record<string, boolean> = {};\n\n    constructor(connection: ConnectionManager) {\n        this._connection = connection;\n\n        for (const msgType of ['tick', 'ohlc']) {\n            this._connection.on(msgType, this._onTick.bind(this));\n        }\n        this._connection.onClosed(this._onConnectionClosed.bind(this));\n    }\n\n    _onTick(data: TicksStreamResponse) {\n        const key = this._getKey((data.echo_req as unknown) as TicksHistoryRequest);\n\n        if (this._streams[key] && this._tickHistoryCache[key]) {\n            this._streamIds[key] = data[data.msg_type]?.id;\n            this._cacheTick(key, data);\n            this._streams[key].emitTick(data);\n        } else if (this._beingForgotten[key] === undefined) {\n            // There could be the possibility a stream could still enter even though\n            // it is no longer in used. This is because we can't know the stream ID\n            // from the initial response; we have to wait for the next tick to retrieve it.\n            // In such scenario we need to forget these \"orphaned\" streams:\n            this._streamIds[key] = data[data.msg_type]?.id;\n            this._forgetStream(key);\n        }\n    }\n\n    _onConnectionClosed() {\n        // StreamManager simply discards all streams upon disconnection;\n        // It is not its responsibility to reestablish the streams upon reconnection.\n        this._streamIds = {}; // set it to blank so that forget requests do not get called\n        for (const key of Object.keys(this._streams)) {\n            if (this._streams[key].subscriberCount !== 0) {\n                this._forgetStream(key);\n            }\n        }\n    }\n\n    _onReceiveTickHistory(data: Required<TicksHistoryResponse>) {\n        const key = this._getKey((data.echo_req as unknown) as TicksHistoryRequest);\n        const cache = StreamManager.cloneTickHistoryResponse(data);\n        if (cache) {\n            this._tickHistoryCache[key] = cache;\n        }\n        delete this._tickHistoryPromises[key];\n    }\n\n    _cacheTick(key: string, response: TicksStreamResponse | OHLCStreamResponse) {\n        if ('ohlc' in response) {\n            const { ohlc } = response as OHLCStreamResponse;\n            const candles = this._tickHistoryCache[key].candles as Candles;\n            const { close, open_time: epoch, high, low, open } = ohlc;\n            const candle: ArrayElement<Candles> = {\n                close: (close as unknown) as number,\n                high: (high as unknown) as number,\n                low: (low as unknown) as number,\n                open: (open as unknown) as number,\n                epoch,\n            };\n            const lastCandle = candles[candles.length - 1] as Required<Candles[0]>;\n            if (lastCandle && candle.epoch && +lastCandle.epoch === +candle.epoch) {\n                candles[candles.length - 1] = candle;\n            } else {\n                candles.push(candle);\n\n                if (candles.length > this.MAX_CACHE_TICKS) {\n                    candles.shift();\n                }\n            }\n        } else if ('tick' in response) {\n            const { tick } = response;\n            const history = this._tickHistoryCache[key].history;\n\n            const { prices, times } = history as Required<History>;\n            const { quote: price, epoch: time } = tick as Required<TickSpotData>;\n\n            prices.push(price);\n            times.push(time);\n\n            if (prices.length > this.MAX_CACHE_TICKS) {\n                prices.shift();\n                times.shift();\n            }\n        }\n    }\n\n    _forgetStream(key: string) {\n        const stream = this._streams[key];\n        if (stream) {\n            // Note that destroying a stream also removes all subscribed events\n            stream.destroy();\n            delete this._streams[key];\n        }\n\n        if (this._streamIds[key]) {\n            const id = this._streamIds[key];\n            this._beingForgotten[key] = true;\n            this._connection.send({ forget: id }).then(() => {\n                delete this._beingForgotten[key];\n                delete this._streamIds[key];\n            });\n        }\n\n        if (this._tickHistoryCache[key]) {\n            delete this._tickHistoryCache[key];\n        }\n    }\n\n    _createNewStream(request: TicksHistoryRequest) {\n        const key = this._getKey(request);\n        const stream = new Stream();\n        this._streams[key] = stream;\n        const subscribePromise = this._connection.send((request as unknown) as TBinaryAPIRequest);\n        this._tickHistoryPromises[key] = subscribePromise as Promise<Required<TicksHistoryResponse>>;\n\n        subscribePromise\n            .then(response => {\n                this._onReceiveTickHistory(response as Required<TicksHistoryResponse>);\n                if (response.error) {\n                    this._forgetStream(key);\n                }\n            })\n            .catch(() => {\n                this._forgetStream(key);\n            });\n\n        stream.onNoSubscriber(() => this._forgetStream(key));\n\n        return stream;\n    }\n\n    async subscribe(req: TBinaryAPIRequest, callback: (response: TicksHistoryResponse) => void) {\n        const request = (req as unknown) as TicksHistoryRequest;\n        const key = this._getKey(request);\n        let stream = this._streams[key];\n        if (!stream) {\n            stream = this._createNewStream(request);\n        }\n\n        let tickHistoryResponse = this._tickHistoryCache[key];\n        if (!tickHistoryResponse) {\n            tickHistoryResponse = await this._tickHistoryPromises[key];\n        }\n\n        const responseStart = ((tickHistoryResponse.echo_req as unknown) as TicksHistoryRequest).start;\n        if (responseStart && request.start && responseStart > request.start) {\n            // request needs more data\n            const patchRequest = { ...request };\n            delete patchRequest.subscribe;\n            const { history, candles } = tickHistoryResponse as Required<TicksHistoryResponse>;\n            patchRequest.end = String(history && history.times?.[0] ? +history.times[0] : candles[0].epoch || '');\n            const patch = (await this._connection.send(patchRequest)) as Required<TicksHistoryResponse>;\n            tickHistoryResponse = mergeTickHistory(tickHistoryResponse, patch);\n        }\n\n        if (tickHistoryResponse.error) {\n            callback(tickHistoryResponse);\n        } else {\n            // If cache data is available, send a copy otherwise we risk\n            // mutating the cache outside of StreamManager\n            callback(StreamManager.cloneTickHistoryResponse(tickHistoryResponse));\n        }\n\n        stream.onStream(callback);\n    }\n\n    forget(request: TBinaryAPIRequest, callback: (response: TicksHistoryResponse) => void) {\n        const key = this._getKey((request as unknown) as TicksHistoryRequest);\n        const stream = this._streams[key];\n        if (stream) {\n            stream.offStream(callback);\n        }\n    }\n\n    _getKey({ ticks_history: symbol, granularity }: TicksHistoryRequest) {\n        return `${symbol}-${granularity || 0}`;\n    }\n\n    static cloneTickHistoryResponse({ history, candles, ...others }: Required<TicksHistoryResponse>) {\n        let clone: TicksHistoryResponse | null = null;\n\n        if (history) {\n            const { prices, times } = history as Required<History>;\n            clone = {\n                ...others,\n                history: {\n                    prices: prices.slice(0),\n                    times: times.slice(0),\n                },\n            };\n        } else if (candles) {\n            clone = { ...others, candles: candles.slice(0) };\n        }\n\n        return clone as Required<TicksHistoryResponse>;\n    }\n}\n\nexport default StreamManager;\n"],"sourceRoot":""}